# Powder Integration 卡顿 - 终极修复方案

## 问题总结
经过多次尝试，以下方案都无效：
1. ❌ 重定向 stdout/stderr
2. ❌ 禁用 tqdm
3. ❌ QThread -> threading.Thread
4. ❌ 延迟启动
5. ❌ 信号分离

## 终极方案：使用子进程 (subprocess)

### 核心思路
**完全隔离集成进程和GUI进程**

- GUI进程：只负责界面显示和用户交互
- 集成进程：独立的Python进程执行实际集成工作
- 即使集成卡住，GUI仍然响应

### 实现方式

#### 方案A: subprocess + 轮询（推荐）

```python
import subprocess
import sys

# 1. 创建独立的执行脚本
script = f'''
from batch_integration import run_batch_integration
run_batch_integration(
    poni_file="{self.poni_path}",
    input_pattern="{self.input_pattern}",
    # ... 其他参数
)
'''

# 2. 启动子进程
process = subprocess.Popen(
    [sys.executable, '-c', script],
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE
)

# 3. 使用QTimer轮询进程状态
def check_status():
    if process.poll() is not None:
        # 进程完成
        timer.stop()
        self.progress.stop()
        self.log("完成！")

timer = QTimer()
timer.timeout.connect(check_status)
timer.start(500)  # 每500ms检查一次
```

**优点**：
- ✅ GUI永远不会卡
- ✅ 可以随时终止进程
- ✅ 子进程崩溃不影响GUI
- ✅ 不需要修改现有代码太多

**缺点**：
- 无法实时获取进度（但可以通过文件或socket通信解决）

#### 方案B: QProcess（Qt原生）

```python
from PyQt6.QtCore import QProcess

class PowderXRDModule:
    def run_integration(self):
        self.process = QProcess(self)
        self.process.finished.connect(self.on_finished)
        self.process.readyReadStandardOutput.connect(self.on_output)
        
        # 构建命令
        script = f'...'  # 集成脚本
        
        self.process.start(sys.executable, ['-c', script])
        self.log("进程已启动")
    
    def on_output(self):
        """实时读取输出"""
        data = self.process.readAllStandardOutput().data().decode()
        self.log(data)
    
    def on_finished(self):
        """进程完成"""
        self.progress.stop()
        self.log("完成！")
```

**优点**：
- ✅ Qt原生，与GUI集成更好
- ✅ 可以实时获取输出
- ✅ 可以发送信号控制子进程

**缺点**：
- 需要稍多的代码修改

#### 方案C: ProcessPoolExecutor（简洁）

```python
from concurrent.futures import ProcessPoolExecutor
import time

def integration_work(poni_path, input_pattern, ...):
    """在独立进程中执行"""
    from batch_integration import run_batch_integration
    return run_batch_integration(...)

class PowderXRDModule:
    def __init__(self):
        self.executor = ProcessPoolExecutor(max_workers=1)
    
    def run_integration(self):
        self.log("启动集成...")
        self.progress.start()
        
        # 提交到进程池
        future = self.executor.submit(
            integration_work,
            self.poni_path,
            self.input_pattern,
            # ... 参数
        )
        
        # 轮询结果
        def check():
            if future.done():
                timer.stop()
                self.progress.stop()
                try:
                    result = future.result()
                    self.log("✓ 完成！")
                except Exception as e:
                    self.log(f"❌ 错误: {e}")
        
        timer = QTimer()
        timer.timeout.connect(check)
        timer.start(500)
```

**优点**：
- ✅ 代码最简洁
- ✅ Python标准库
- ✅ 自动管理进程池

**缺点**：
- 参数传递必须可pickle
- 无法实时获取输出

## 推荐实施步骤

### 第一步：添加子进程运行器

在 `powder_module.py` 添加：

```python
import subprocess
import sys
import os

def run_integration_subprocess(self):
    """使用子进程运行集成"""
    try:
        # 验证参数...
        
        self.log("="*60)
        self.log("Starting integration in subprocess...")
        self.progress.start()
        
        # 准备参数
        formats = self._collect_formats()
        unit_pyFAI = self._convert_unit()
        
        # 创建脚本
        script = self._create_integration_script(
            poni_path=self.poni_path,
            mask_path=self.mask_path,
            input_pattern=self.input_pattern,
            output_dir=self.output_dir,
            dataset_path=self.dataset_path,
            npt=self.npt,
            unit=unit_pyFAI,
            formats=formats,
            create_stacked_plot=self.create_stacked_plot,
            stacked_plot_offset=self.stacked_plot_offset
        )
        
        # 启动子进程
        self.integration_process = subprocess.Popen(
            [sys.executable, '-c', script],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            cwd=os.getcwd()
        )
        
        # 启动状态检查定时器
        if hasattr(self, 'check_timer'):
            self.check_timer.stop()
        
        self.check_timer = QTimer()
        self.check_timer.timeout.connect(self._check_integration_status)
        self.check_timer.start(500)
        
        self.log("✓ Subprocess started successfully")
        
    except Exception as e:
        self.progress.stop()
        self.log(f"❌ Error: {str(e)}")
        self.show_error("Error", str(e))

def _create_integration_script(self, **params):
    """创建集成脚本"""
    return f'''
import sys
sys.path.insert(0, "{os.path.dirname(os.path.abspath(__file__))}")

try:
    from batch_integration import run_batch_integration
    
    run_batch_integration(
        poni_file="{params['poni_path']}",
        mask_file="{params['mask_path']}" if "{params['mask_path']}" else None,
        input_pattern="{params['input_pattern']}",
        output_dir="{params['output_dir']}",
        dataset_path="{params['dataset_path']}" if "{params['dataset_path']}" else None,
        npt={params['npt']},
        unit="{params['unit']}",
        formats={params['formats']},
        create_stacked_plot={params['create_stacked_plot']},
        stacked_plot_offset="{params['stacked_plot_offset']}",
        disable_progress_bar=True
    )
    
    print("\\n=== SUCCESS ===")
    
except Exception as e:
    print(f"\\n=== ERROR: {{e}} ===")
    import traceback
    traceback.print_exc()
'''

def _check_integration_status(self):
    """检查子进程状态"""
    if hasattr(self, 'integration_process'):
        retcode = self.integration_process.poll()
        
        if retcode is not None:
            # 进程结束
            self.check_timer.stop()
            self.progress.stop()
            
            stdout, stderr = self.integration_process.communicate()
            
            if "SUCCESS" in stdout:
                self.log("✓ Integration completed successfully!")
                self.log("="*60)
                self.show_success("Success", "Batch integration completed!")
            else:
                self.log("❌ Integration failed")
                if stderr:
                    self.log(f"Error: {stderr[:500]}")  # 只显示前500字符
                self.log("="*60)
                self.show_error("Error", "Integration failed. Check log.")
            
            # 清理
            del self.integration_process

def _collect_formats(self):
    """收集输出格式"""
    formats = []
    if self.format_xy: formats.append('xy')
    if self.format_dat: formats.append('dat')
    if self.format_chi: formats.append('chi')
    if self.format_fxye: formats.append('fxye')
    if self.format_svg: formats.append('svg')
    if self.format_png: formats.append('png')
    return formats if formats else ['xy']

def _convert_unit(self):
    """转换单位"""
    unit_map = {
        '2θ (°)': '2th_deg',
        'q (nm⁻¹)': 'q_nm^-1',
        'q (A⁻¹)': 'q_A^-1',
        'r (mm)': 'r_mm'
    }
    return unit_map.get(self.unit, '2th_deg')
```

### 第二步：修改按钮连接

在 `setup_integration_module()` 中：

```python
run_int_btn = ModernButton(
    "Run Integration",
    self.run_integration_subprocess,  # 使用新方法
    # ...
)
```

### 第三步：添加终止功能（可选）

```python
def cancel_integration(self):
    """取消正在运行的集成"""
    if hasattr(self, 'integration_process'):
        self.integration_process.terminate()
        self.check_timer.stop()
        self.progress.stop()
        self.log("✗ Integration cancelled by user")
```

## 为什么这个方案肯定有效？

1. **完全隔离**: 子进程在独立的操作系统进程中运行
2. **不共享内存**: GUI和集成进程完全独立
3. **系统级解决**: 操作系统保证进程隔离
4. **可终止**: 随时可以kill子进程而不影响GUI
5. **经过验证**: subprocess是Python标准库，非常稳定

## 测试方法

1. 实施修改
2. 点击"Run Integration"
3. **观察**:
   - GUI窗口应该可以拖动
   - 进度条应该流畅动画
   - 可以点击其他按钮
4. 等待集成完成或查看日志

## 如果还是有问题

如果使用子进程后仍然卡住，那问题可能是：

1. **进度条本身**: 尝试禁用进度条动画
2. **日志更新**: 尝试减少日志频率
3. **Qt事件循环**: 可能需要调用 `QApplication.processEvents()`
4. **系统资源**: CPU/内存耗尽

但这些可能性极低，因为子进程方案已经完全隔离了计算负载。

## 总结

这是最终方案，因为：
- ✅ 使用操作系统级别的进程隔离
- ✅ 不依赖Python的GIL
- ✅ 不依赖Qt的线程机制
- ✅ 简单、可靠、易于实现
- ✅ 可以终止、监控、调试

**如果这个方案还不行，那问题一定在GUI本身（进度条、日志等），而不是集成代码。**
